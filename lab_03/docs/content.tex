\section*{Тема работы}

Программно-алгоритмическая реализация моделей на основе ОДУ второго порядка с краевыми условиями II и III рода.

\section*{Цель работы}

Получение навыков разработки алгоритмов решения краевой задачи при реализации моделей, построенных на ОДУ второго порядка.

\chapter{Теоретические сведения}

Задана математическая модель:

\begin{equation*}
	\frac{d}{dx}(\lambda(T)\frac{dT}{dx}) - 4 \cdot k(T) \cdot n_{p}^2 \cdot \sigma \cdot (T^4 - T_{0}^4) = 0
\end{equation*}\\

Краевые условия:

\begin{equation*}
	\begin{cases} x = 0, -\lambda(T(0))\frac{dT}{dx} = F_{0}.
	\\ x = l, -\lambda(T(l))\frac{dT}{dx} = \alpha(T(l) - T_{0})
	\end{cases}
\end{equation*}\\

Функции $\lambda(T)$ и $k(T)$ заданы таблицей.\\

Заданы начальные параметры:\\
\indent $n_p$ = 1.4 - коэффициент преломления\\
\indent $l$ = 0.2 см - толщина слоя\\
\indent $T_{0}$ = 300К - температура окружающей среды\\
\indent $\sigma$ = 5.668 $\cdot 10^{-12}$ Вт / ($cm^2 \cdot K^4$) - постоянная Стефана - Больцмана\\
\indent $F_{0}$ = 100 Вт / $cm^2$ - поток тепла\\
\indent $\alpha$ = 0.05 Вт / ($cm^2 \cdot K$) - коэффициент теплоотдачи\\

Выход из итераций организовать по температуре и по балансу энергии:

\begin{equation*}
	max|\frac{y^s_n - y^{s-1}_n}{y^s_n}| <= \varepsilon_{1}
\end{equation*} 

\indent для всех $n = 0, 1, ... N.$ и \\

\begin{equation*}
	max|\frac{f^s_1 - y^s_2}{f^s_1}| <= \varepsilon_{1}
\end{equation*}

где \\

\begin{equation*}
	f_{1} = F_0 - \alpha(T(l) - T_{0})
\end{equation*}

\begin{equation*}
	f_{2}  = 4n^2_p \sigma ^1_0 k(T(x))(T^4(x) - T^4_0) dx
\end{equation*}

\chapter{Реализация}

\section{Код программы}

Ниже представлены исходные коды программы на языке \texttt{Python}.

\begin{lstlisting}[language=python]
from math import pow
from scipy.interpolate import InterpolatedUnivariateSpline
import plot

class Params:
    Np = 1.4
    l = 0.2
    T0 = 300
    sigma = 5.668*1e-12
    F0 = 100
    alpha = 0.05
    h = 1e-4
 
    fst_table = ((300, 500, 800, 1100, 2000, 2400), 
            (1.36 * pow(10, -2), 1.63 * pow(10, -2), 1.81 * pow(10, -2),
            1.98 * pow(10, -2), 2.50 * pow(10, -2), 2.74 * pow(10, -2)))
 
    snd_table = ((293, 1278, 1528, 1677, 2000, 2400),
        (2.0 * pow(10, -2), 5.0 * pow(10, -2), 7.8 * pow(10, -2),
        1.0 * pow(10, -1), 1.3 * pow(10, -1), 2.0 * pow(10, -1)),)
 
params = Params()

interpolate = lambda x_pts, y_pts, order=1: InterpolatedUnivariateSpline(x_pts, y_pts, k=order)
p = lambda k_t, t, n: 4 * params.Np * params.Np * params.sigma * k_t(t[n]) * pow(t[n], 3)
f = lambda k_t, t, n: 4 * params.Np * params.Np + params.sigma * k_t(t[n]) * pow(params.T0, 4)

x_right = lambda l_t, t, n: (l_t(t[n]) + l_t(t[n + 1])) / 2
x_left = lambda l_t, t, n: (l_t(t[n]) + l_t(t[n - 1])) / 2
p_right = lambda k_t, t, n: (p(k_t, t, n) + p(k_t, t, n + 1)) / 2
p_left = lambda k_t, t, n: (p(k_t, t, n) + p(k_t, t, n - 1)) / 2
f_right = lambda k_t, t, n: (f(k_t, t, n) + f(k_t, t, n + 1)) / 2
f_left = lambda k_t, t, n: (f(k_t, t, n) + f(k_t, t, n - 1)) / 2

A = lambda l_t, t, n: (l_t(t[n]) + l_t(t[n - 1])) / 2 / params.h
B = lambda l_t, k_t, t, n: A(l_t, t, n) + C(l_t, t, n) + \
    4 * params.Np * params.Np * params.sigma * k_t(t[n]) * pow(t[n], 3) * params.h
C = lambda l_t, t, n: (l_t(t[n]) + l_t(t[n + 1])) / 2 / params.h
D = lambda k_t, t, n: 4 * params.Np * params.Np + params.sigma * k_t(t[n]) * pow(params.T0, 4) * params.h

def right_conditions(l_t, k_t, t):
    K0 = x_right(l_t, t, 0) + pow(params.h, 2) / 8 * p_right(k_t, t, 0) + pow(params.h, 2) / 4 * p(k_t, t, 0)
    M0 = pow(params.h, 2) / 8 * p_right(k_t, t, 0) - x_right(l_t, t, 0)
    P0 = params.h * params.F0 + pow(params.h, 2) / 4 * (f_right(k_t, t, 0) + f_left(k_t, t, 0))
    return K0, M0, P0

def left_conditions(k_t, l_t, t, n):
    Kn = x_left(l_t, t, n) / params.h - params.alpha - params.h * p(k_t, t, n) / 4 \
        - params.h * p_left(k_t, t, n) / 8
    Mn = x_left(l_t, t, n) / params.h - params.h * p_left(k_t, t, n) / 8
    Pn = -(params.alpha * params.T0 + (f_right(k_t, t, n) + f_left(k_t, t, n)) / 4 * params.h)
    return Kn, Mn, Pn

def start():
    l_t = interpolate(params.fst_table[0], params.fst_table[1])
    k_t = interpolate(params.snd_table[0], params.snd_table[1])
    t = [0 for _ in range(int(1 / params.h) + 2)]
    K0, M0, P0 = right_conditions(l_t, k_t, t)
    xi_list = [0]
    eta_list = [0]
    x_list = list()
    x = 0
    n = 0
    while x + params.h < 1:
        x_list.append(x)
        xi_list.append(C(l_t, t, n) / (B(l_t, k_t, t, n) - A(l_t, t, n) * xi_list[n]))
        eta_list.append((D(k_t, t, n) + A(l_t, t, n) * xi_list[n]) / (B(l_t, k_t, t, n) - \
                                                                      A(l_t, t, n) * xi_list[n]))
        n += 1
        x += params.h
        x_list.extend([x + params.h, x + params.h * 2])
        Kn, Mn, Pn = left_conditions(k_t, l_t, t, n)
        t[n] = (Pn - Mn * xi_list[n]) / (Kn + Mn * xi_list[n])
        for i in range(n - 1, -1, -1):
            t[i] = xi_list[i + 1] * t[i + 1] + eta_list[i + 1]
            plot.add_figure(figure_id=1, subplot=321, x=x_list, y=t, label='T (x)', \
                            x_label='x', y_label='T', grid=True)
            plot.show()
\end{lstlisting}

\section{Результаты работы программы}

\subsection{Представить разностный аналог краевого условия при $x = l$ и его краткий вывод интегро-интерполяционным методом.}

Проинтегрируем уравнение на отрезке [$X_{n - \frac{1}{2}}; x_{n}$]

\begin{equation*}
	- \int^{x_{n}}_{x_n - \frac{1}{2}} \frac{dF}{dx} dT - \int^{x_n}_{x_n - \frac{1}{2}} P(T) \cdot T^4 dT + \int^{x_{n}}_{x_{n} - \frac{1}{2}} f(t) dT = 0
\end{equation*}

Второй и третий интеграл вычислим с помощью метода трапеций:

\begin{equation*}
	F_{n - \frac{1}{2}} - F_{n} - \frac{h}{4} (p_{n} y_{n} + p_{n - \frac{1}{2}}y_{n-\frac{1}{2}}) + \frac{h}{4} (f_{n} + f_{n - \frac{1}{2}}) = 0
\end{equation*}

Зная, что: 

\begin{equation*}
	F_{n - \frac{1}{2}} = x_{n - \frac{1}{2}} \frac{y_{n - 1}}{y_n}{h}
\end{equation*}

\begin{equation*}
	F_{n} = \alpha_{n}(y_{n} - T_{0})
\end{equation*}

\begin{equation*}
	y_{n - \frac{1}{2}} = \frac{y_{n} + y_{n - 1}}{2h}
\end{equation*}

Имеем:

\begin{equation*}
	\frac{x_{n - \frac{1}{2}} y_{n - 1}}{h} - \frac{x_{n - \frac{1}{2}}y_{n}}{h} - \alpha_{n}y_{n} + \alpha_{n} T_{0} - \frac{hp_{n}y_{n}}{48} - \frac{hp_{n - \frac{1}{2}}y_{n}}{8} - \frac{hp_{n - \frac{1}{2}}y_{n - 1}}{8} + \frac{f_{n - \frac{1}{2}} + f_{n}}{4}h = 0
\end{equation*}

\begin{equation*}
	y_{n}(-\frac{x_{n - \frac{1}{2}}}{h} - \alpha_{n} - \frac{hp_{n}}{4} - \frac{hp_{n} - \frac{1}{2}}{8}) + y_{n - 1}(\frac{x_{n - \frac{1}{2}}}{h} - \frac{hp_{n - \frac{1}{2}}}{8}) = -(\alpha_{n}T_{0} + \frac{f_{n} - \frac{1}{2}}{4}h)
\end{equation*}

\clearpage

\subsection{График зависимости температуры $T(x)$ координаты $x$ при заданных выше параметрах.}

\imgw{150mm}{1}{График зависимости температуры $T(x)$ координаты $x$ при заданных выше параметрах.}

\clearpage

\subsection{График зависимости $T(x)$ при $F_{0} = -10 \frac{Bт}{cm^2}$}

\imgw{150mm}{2}{График зависимости $T(x)$ при $F_{0} = -10 \frac{Bт}{cm^2}$}

\clearpage

\subsection{График зависимости $T(x)$ при увеличенных значениях $\alpha$ (например, в 3 раза). Сравнить с п. 2.}

\imgw{150mm}{3}{График зависимости $T(x)$ при увеличенных значениях $\alpha$ (например, в 3 раза). (график из п. 2 - фиолетовый)}

\clearpage

\subsection{График зависимости $T(x)$ при $F_{0} = 0$.}

\imgw{150mm}{4}{График зависимости $T(x)$ при $F_{0} = 0$.}

\subsection{Для указанного в задании исходного набора параметров привести данные по балансу энергии.}\\

\begin{itemize}
	\item Точность выхода $\varepsilon_{1} = 0.067$ (по температуре)
	\item Точность выхода $\varepsilon_{2} = 1.11$ (по балансу)
\end{itemize}

\chapter{Ответы на вопросы}

\section{Какие способы тестирования программы можно предложить?}

Корректность работы программы можно проверить для следующих известных закономерностей:
\begin{itemize}
    \item При $F_0 > 0$ происходит охлаждение пластины ($T$ убывает), при $F_0 < 0$ нагревание ($T$ возрастает);
    \item при увеличении показателя теплосъема, уровень должен снижаться (обратная пропорциональность);
    \item при увеличении показателя теплосъема, градиент должен увеличиваться (прямая пропорциональность).
\end{itemize}

\clearpage

\section{Получите простейший разностный аналог нелинейного краевого условия при $x = l$.}

\imgw{150mm}{a1}{простейший разностный аналог нелинейного краевого условия при $x = l$}


\section{Опишите алгоритм применения метода прогонки, если при $x = 0$ краевое условие квазилинейное (как в настоящей работе), а при $x = l$, как в п. 2.}

\imgw{150mm}{a2}{алгоритм применения метода прогонки}

\clearpage

\section{Опишите алгоритм определения единственного значения сеточной функции $y_p$ в одной заданной точке $p$. Использовать встречную прогонку, т.е. комбинацию правой и левой прогонок.}

\imgw{150mm}{a3}{алгоритм определения единственного значения сеточной функции $y_p$ в одной заданной точке $p$}
